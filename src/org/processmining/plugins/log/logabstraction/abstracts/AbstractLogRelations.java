package org.processmining.plugins.log.logabstraction.abstracts;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.Pair;
import org.processmining.plugins.log.logabstraction.LogRelations;

public abstract class AbstractLogRelations implements LogRelations {

	protected final XLog log;
	protected final XLogInfo summary;
	protected final XEventClasses classes;
	/* Matrices filled by AbstractLogRelations */
	protected final List<XEventClass> eventClasses;
	protected final int[][] absoluteDirectlyFollowsMatrix;
	protected final int[][] absoluteLengthTwoLoopMatrix;
	protected final int[] starts;
	protected final int[] ends;
	/* Matrices to be filled by child classes */
	protected final double[][] causalMatrix;
	protected final Map<Pair<XEventClass, XEventClass>, Set<XTrace>> dfrTraceMap = new HashMap<Pair<XEventClass, XEventClass>, Set<XTrace>>();
	protected Progress progress;

	public AbstractLogRelations(XLog log) {
		this(log, XLogInfoFactory.createLogInfo(log), null);
	}

	public AbstractLogRelations(XLog log, XLogInfo summary) {
		this(log, summary, null);
	}

	public AbstractLogRelations(XLog log, Progress progress) {
		this(log, XLogInfoFactory.createLogInfo(log), progress);
	}

	public AbstractLogRelations(XLog log, XLogInfo summary, Progress progress) {
		this.log = log;
		this.summary = summary;
		this.classes = summary.getEventClasses();
		initializeProgress(progress);

		XEventClass[] eventClassIndexes = setupEventClasses();
		this.eventClasses = Arrays.asList(eventClassIndexes);
		this.absoluteDirectlyFollowsMatrix = new int[this.classes.size()][this.classes.size()];
		this.absoluteLengthTwoLoopMatrix = new int[this.classes.size()][this.classes.size()];

		this.starts = new int[this.classes.size()];
		this.ends = new int[this.classes.size()];

		this.causalMatrix = new double[this.classes.size()][this.classes.size()];

		expandProgress();
		calculateLogRelations();
	}

	private void initializeProgress(Progress progress) {
		if (!(progress == null)) {
			this.progress = progress;
			this.progress.setMinimum(0);
			this.progress.setMaximum(this.log.size());
		}
	}

	protected XEventClass[] setupEventClasses() {
		XEventClass[] result = new XEventClass[this.classes.size()];
		int i = 0;
		for (XEventClass xClass : this.classes.getClasses()) {
			result[i] = xClass;
			i++;
		}
		return result;
	}

	protected abstract void calculateLogRelations();

	/**
	 * Add to the progress, the additional cost of computation generated by
	 * calculate metrics.
	 */
	protected abstract void expandProgress();

	protected abstract void calculateMetrics();

	/**
	 * Makes dfrPairs succession relations, as well as two-loop relations, i.e.
	 * searches through the log for AB patterns and ABA patterns
	 */
	protected void fillDirectSuccessionMatrices() {
		for (XTrace trace : this.log) {
			if (!trace.isEmpty()) {
				this.starts[this.eventClasses.indexOf(classes.getClassOf(trace.get(0)))]++;
				for (int i = 0; i < trace.size() - 1; i++) {
					XEventClass from = classes.getClassOf(trace.get(i));
					XEventClass to = classes.getClassOf(trace.get(i + 1));
					if (traceContainsLengthTwoConstruct(trace, i, from, to)) {
						this.absoluteLengthTwoLoopMatrix[this.eventClasses.indexOf(from)][this.eventClasses
								.indexOf(to)]++;
					}
					storePair(this.eventClasses.indexOf(from), this.eventClasses.indexOf(to), trace);
				}
				this.ends[this.eventClasses.indexOf(classes.getClassOf(trace.get(trace.size() - 1)))]++;
			}
			increaseProgress();
		}
	}

	protected final void increaseProgress() {
		if (progress != null)
			progress.inc();
	}

	protected boolean traceContainsLengthTwoConstruct(XTrace trace, int fromIndex, XEventClass from, XEventClass to) {
		return fromIndex < trace.size() - 2 && !(from.equals(to))
				&& from.equals(classes.getClassOf(trace.get(fromIndex + 2)));
	}

	protected void storePair(int fromIndex, int toIndex, XTrace trace) {
		this.absoluteDirectlyFollowsMatrix[fromIndex][toIndex]++;

		Pair<XEventClass, XEventClass> pair = new Pair<XEventClass, XEventClass>(this.eventClasses.get(fromIndex),
				this.eventClasses.get(toIndex));
		Set<XTrace> traces = (this.dfrTraceMap.containsKey(pair) ? this.dfrTraceMap.get(pair) : new HashSet<XTrace>());
		traces.add(trace);
		this.dfrTraceMap.put(pair, traces);
	}

	@Override
	public Pair<List<XEventClass>, int[][]> absoluteDirectlyFollowsMatrix() {
		return new Pair<List<XEventClass>, int[][]>(this.eventClasses, this.absoluteDirectlyFollowsMatrix);
	}

	@Deprecated
	public Map<XEventClass, Integer> getEndTraceInfo() {
		return getEndEvents();
	}

	@Deprecated
	public XEventClasses getEventClasses() {
		return this.classes;
	}

	@Deprecated
	public Map<Pair<XEventClass, XEventClass>, Integer> getLengthTwoLoops() {
		Map<Pair<XEventClass, XEventClass>, Integer> result = new HashMap<Pair<XEventClass, XEventClass>, Integer>();
		for (int i = 0; i < this.absoluteLengthTwoLoopMatrix.length; i++) {
			for (int j = 0; j < this.absoluteLengthTwoLoopMatrix[i].length; j++) {
				if (this.absoluteLengthTwoLoopMatrix[i][j] > 0) {
					XEventClass from = this.eventClasses.get(i);
					XEventClass to = this.eventClasses.get(j);
					result.put(new Pair<XEventClass, XEventClass>(from, to), this.absoluteLengthTwoLoopMatrix[i][j]);
				}
			}
		}
		return result;
	}

	public Map<Pair<XEventClass, XEventClass>, Double> lengthTwoLoops() {
		Map<Pair<XEventClass, XEventClass>, Double> result = new HashMap<Pair<XEventClass, XEventClass>, Double>();
		for (int i = 0; i < this.absoluteLengthTwoLoopMatrix.length; i++) {
			for (int j = 0; j < this.absoluteLengthTwoLoopMatrix[i].length; j++) {
				if (this.absoluteLengthTwoLoopMatrix[i][j] > 0) {
					XEventClass from = this.eventClasses.get(i);
					XEventClass to = this.eventClasses.get(j);
					result.put(new Pair<XEventClass, XEventClass>(from, to),
							(double) this.absoluteLengthTwoLoopMatrix[i][j]);
				}
			}
		}
		return result;
	}

	@Deprecated
	public XLog getLog() {
		return this.log;
	}

	public Map<XEventClass, Integer> getStartTraceInfo() {
		return getStartEvents();
	}

	public XLogInfo getSummary() {
		return summary;
	}

	public Map<Pair<XEventClass, XEventClass>, Integer> getDirectFollowsDependencies() {
		Map<Pair<XEventClass, XEventClass>, Integer> result = new HashMap<Pair<XEventClass, XEventClass>, Integer>();
		for (int i = 0; i < this.absoluteDirectlyFollowsMatrix.length; i++) {
			for (int j = 0; j < this.absoluteDirectlyFollowsMatrix[i].length; j++) {
				if (this.absoluteDirectlyFollowsMatrix[i][j] > 0) {
					XEventClass from = this.eventClasses.get(i);
					XEventClass to = this.eventClasses.get(j);
					result.put(new Pair<XEventClass, XEventClass>(from, to), this.absoluteDirectlyFollowsMatrix[i][j]);
				}
			}
		}
		return result;
	}

	public Map<Pair<XEventClass, XEventClass>, Set<XTrace>> getCountDirect() {
		return dfrTraceMap;
	}

	@Override
	@Deprecated
	public Map<Pair<XEventClass, XEventClass>, Double> getCausalDependencies() {
		Map<Pair<XEventClass, XEventClass>, Double> result = new HashMap<Pair<XEventClass, XEventClass>, Double>();
		for (int i = 0; i < this.causalMatrix.length; i++) {
			for (int j = 0; j < this.causalMatrix[i].length; j++) {
				if (this.causalMatrix[i][j] > 0) {
					XEventClass from = this.eventClasses.get(i);
					XEventClass to = this.eventClasses.get(j);
					result.put(new Pair<XEventClass, XEventClass>(from, to), this.causalMatrix[i][j]);
				}
			}
		}
		return result;
	}

	@Override
	public Map<Pair<XEventClass, XEventClass>, Double> causalDependencies() {
		Map<Pair<XEventClass, XEventClass>, Double> result = new HashMap<Pair<XEventClass, XEventClass>, Double>();
		for (int i = 0; i < this.causalMatrix.length; i++) {
			for (int j = 0; j < this.causalMatrix[i].length; j++) {
				if (i != j) {
					XEventClass from = this.eventClasses.get(i);
					XEventClass to = this.eventClasses.get(j);
					result.put(new Pair<XEventClass, XEventClass>(from, to), this.causalMatrix[i][j]);
				}
			}
		}
		return result;
	}

	@Override
	public Map<XEventClass, Integer> getLengthOneLoops() {
		Map<XEventClass, Integer> result = new HashMap<XEventClass, Integer>();
		for (int index = 0; index < this.eventClasses.size(); index++) {
			if (this.absoluteDirectlyFollowsMatrix[index][index] > 0) {
				result.put(this.eventClasses.get(index), this.absoluteDirectlyFollowsMatrix[index][index]);
			}
		}
		return result;
	}

	@Override
	public Map<XEventClass, Double> lengthOneLoops() {
		Map<XEventClass, Double> result = new HashMap<XEventClass, Double>();
		for (int index = 0; index < this.eventClasses.size(); index++) {
			if (this.absoluteDirectlyFollowsMatrix[index][index] > 0) {
				result.put(this.eventClasses.get(index), (double) this.absoluteDirectlyFollowsMatrix[index][index]);
			}
		}
		return result;
	}

	public Pair<List<XEventClass>, double[][]> causalMatrix() {
		return new Pair<List<XEventClass>, double[][]>(this.eventClasses, this.causalMatrix);
	}

	public XLog getSource() {
		return log;
	}

	public Map<XEventClass, Integer> getStartEvents() {
		Map<XEventClass, Integer> result = new HashMap<XEventClass, Integer>();
		for (int i = 0; i < this.starts.length; i++) {
			if (this.starts[i] > 0) {
				result.put(this.eventClasses.get(i), this.starts[i]);
			}
		}
		return result;
	}

	public Map<XEventClass, Integer> getEndEvents() {
		Map<XEventClass, Integer> result = new HashMap<XEventClass, Integer>();
		for (int i = 0; i < this.ends.length; i++) {
			if (this.ends[i] > 0) {
				result.put(this.eventClasses.get(i), this.ends[i]);
			}
		}
		return result;
	}
}
